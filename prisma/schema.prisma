// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
}

enum UnitOfMeasure {
  QUANTITY
  WEIGHT
}

model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique
  name          String
  password_hash String
  gender        Gender
  avatar_url    String?
  is_admin      Boolean  @default(false)
  is_premium    Boolean  @default(false)
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  couple_id Int?

  refresh_tokens   UserRefreshToken[]
  couple_invites   CoupleInvite[]     @relation(name: "InviterRelation")
  couple           Couple?            @relation(fields: [couple_id], references: [id])
  ShoppingLists    ShoppingList[]
  ShoppingListItem ShoppingListItem[]
  CreatedCalendarEvents CalendarEvent[]
  CreatedHouseholdTasks   HouseholdTask[]           @relation("UserWhoCreatedTask")
  CompletedHouseholdTasks HouseholdTaskCompletion[] @relation("UserWhoCompletedTask")
  CreatedHouseholdTaskExceptions HouseholdTaskException[]
}

model CoupleInvite {
  id            Int       @id @default(autoincrement())
  inviter_id    Int
  invitee_email String
  invited_at    DateTime  @default(now())
  accepted_at   DateTime?
  rejected_at   DateTime?

  inviter User @relation(name: "InviterRelation", fields: [inviter_id], references: [id])
}

model Couple {
  id            Int            @id @default(autoincrement())
  invite_id     Int
  inviter_id    Int
  invitee_id    Int
  created_at    DateTime       @default(now())
  is_active     Boolean        @default(true)

  User          User[]
  Product       Product[]
  ShoppingLists ShoppingList[]
  CalendarEvents CalendarEvent[]
  HouseholdTasks HouseholdTask[]
}

model UserRefreshToken {
  id         Int      @id @default(autoincrement())
  user_id    Int
  user       User     @relation(fields: [user_id], references: [id])
  token      String   @unique
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  expires_at DateTime
}

model Product {
  id              Int           @id @default(autoincrement())
  name            String        @unique
  unit_of_measure UnitOfMeasure
  couple_id       Int

  items ShoppingListItem[]
  couple Couple @relation(fields: [couple_id], references: [id])
}

model ShoppingListItem {
  id               Int      @id @default(autoincrement())
  is_checked       Boolean  @default(false)
  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt
  quantity         Int      @default(1)
  unit_price       Decimal?
  shopping_list_id Int
  product_id       Int
  author_id        Int

  shopping_list ShoppingList @relation(fields: [shopping_list_id], references: [id])
  product       Product      @relation(fields: [product_id], references: [id])
  author        User         @relation(fields: [author_id], references: [id])
}

model ShoppingList {
  id         Int       @id @default(autoincrement())
  name       String?
  couple_id  Int
  author_id  Int
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  closed_at  DateTime?

  author           User               @relation(fields: [author_id], references: [id])
  couple           Couple             @relation(fields: [couple_id], references: [id])
  ShoppingListItem ShoppingListItem[]
}

model CalendarEventCategory {
  id    Int     @id @default(autoincrement())
  name  String  @unique // Ex: "Aniversário", "Trabalho", "Lazer"
  color String? // Ex: "#FF5733", para o frontend saber como exibir

  events CalendarEvent[]
}

model CalendarEvent {
  id              Int      @id @default(autoincrement())
  title           String
  description     String?
  start_time      DateTime // Data e hora da *primeira* ocorrência do evento
  end_time        DateTime // Data e hora do *fim* da primeira ocorrência
  is_all_day      Boolean  @default(false)

  // O "coração" da funcionalidade de recorrência:
  // Armazena uma string no formato iCalendar (RRULE) - (RFC 5545)
  // Ex: "FREQ=YEARLY" (para aniversários)
  // Ex: "FREQ=WEEKLY;BYDAY=MO" (toda segunda-feira)
  // Se for NULO, o evento é único (não se repete).
  recurrence_rule String?

  couple_id       Int
  author_id       Int
  category_id     Int? // Opcional, para vincular à categoria (Aniversário, etc)

  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  couple    Couple                 @relation(fields: [couple_id], references: [id])
  author    User                   @relation(fields: [author_id], references: [id])
  category  CalendarEventCategory? @relation(fields: [category_id], references: [id])
}

model HouseholdTask {
  id              Int      @id @default(autoincrement())
  title           String
  description     String?
  couple_id       Int
  author_id       Int      // <-- Responde: "quem cadastrou essa tarefa"
  start_date      DateTime // Data de início da regra ou data de vencimento (para tarefas únicas)
  
  // Regra de repetição (igual ao Calendário)
  // Se null: é uma "tarefa única"
  // Se "FREQ=DAILY": é uma tarefa que se repete diariamente
  recurrence_rule String?  

  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt
  deleted_at      DateTime?

  author      User                      @relation("UserWhoCreatedTask", fields: [author_id], references: [id])
  couple      Couple                    @relation(fields: [couple_id], references: [id])
  completions HouseholdTaskCompletion[]
  exceptions  HouseholdTaskException[]
}

model HouseholdTaskCompletion {
  id                   Int      @id @default(autoincrement())
  household_task_id    Int      // Link para a definição da tarefa (ex: "Lavar a louça")
  completed_by_user_id Int      // <-- Responde: "quem concluiu"
  completed_at         DateTime @default(now()) // A hora exata que o usuário deu "check"
  
  // Este é o campo mais importante para "organizar por dia"
  // Armazena para qual dia esta conclusão se refere (ex: 2025-10-23)
  task_due_date        DateTime @db.Date 

  household_task HouseholdTask @relation(fields: [household_task_id], references: [id])
  completed_by   User          @relation("UserWhoCompletedTask", fields: [completed_by_user_id], references: [id])

  // Garante que uma tarefa (ex: "Lavar Louça") só possa ser concluída UMA VEZ por dia de vencimento.
  @@unique([household_task_id, task_due_date])
}

model HouseholdTaskException {
  id                  Int      @id @default(autoincrement())
  household_task_id   Int      // Link para a definição da tarefa
  exception_date      DateTime @db.Date // O dia (YYYY-MM-DD) que foi cancelado
  created_at          DateTime @default(now())
  created_by_user_id  Int      // Quem cancelou

  household_task HouseholdTask @relation(fields: [household_task_id], references: [id])
  created_by     User          @relation(fields: [created_by_user_id], references: [id])

  // Garante que uma tarefa só possa ser cancelada UMA VEZ para um dia específico
  @@unique([household_task_id, exception_date])
}